#!/usr/bin/python3

# This script is a wrapper to run PriME with OpenMPI

###########################################################################
#Copyright (c) 2015 Princeton University
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#    * Neither the name of Princeton University nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
#THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY "AS IS" AND
#ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY
#DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################

import getopt
import os 
import sys 
from optparse import OptionParser
import time
import xml.etree.ElementTree as ET
from datetime import datetime
from os import path

prime_path  = os.environ.get('PRIME_PATH') 
prime_exe = path.join(prime_path, 'bin/prime')
prime_so = path.join(prime_path, 'bin/prime.so')
pinwrapper_exe = path.join(prime_path, 'bin/pin_wrapper')

def get_max_msg_size(config_file : str):
    tree = ET.parse(config_file)
    root = tree.getroot()
    return root.find("max_msg_size").text


def run_prime_slurm(config_path : str, output_path : str, threads : str, progs : list, dry : bool, background : bool, params : str):
    config_path = path.abspath(config_path)
    output_path = path.abspath(output_path)
    max_msg_size = get_max_msg_size(config_path)
    task_id = datetime.now().strftime("p_%d%m%Y-%H%M%S")

    task_filename = path.join(prime_path, "cmd", task_id)
    with open(task_filename, "w") as f:
      prime_cmd_with_args = "%s %s %s" % (prime_exe , config_path , output_path)
      f.write("0 %s\n" % prime_cmd_with_args)
      for rank, prog in enumerate(progs, start=1):
        if prog[:7] == 'parsec.':
          pinwrapper_cmd_with_args = "parsecmgmt -a run -c icc -i simsmall -k -s '%s -i %s -p %d -l %s ' -p %s -n %s \n" % (pinwrapper_exe, task_id, rank, max_msg_size, prog, threads)
        else:
          pinwrapper_cmd_with_args = "%s -i %s -p %d -l %s %s\n" % (pinwrapper_exe, task_id, rank, max_msg_size, prog)
        f.write("%d %s" % (rank, pinwrapper_cmd_with_args))

    if background:
      batch_filename = path.join(prime_path, "batch", task_id)
      with open(batch_filename, "w") as f:
        f.write("#!/bin/bash\n")
        f.write("export OMP_NUM_THREADS=%s\n" % threads)
        f.write("srun --multi-prog %s\n" % task_filename)
      cmd = ["sbatch", "-n%d" % (len(progs)+1), "-o%s" % (output_path+'.log')] + params.split(' ') + [batch_filename]

    else:
      cmd = ["srun"] + params.split(' ') + ["--multi-prog", task_filename]
    
    if not background:
      print("export OMP_NUM_THREADS=%s" % threads)
    for word in cmd:
      print(word, end=" ")
    print("")
    if not dry:
      if not background:
        os.environ["OMP_NUM_THREADS"] = threads
      os.execvp(cmd[0], cmd)


def run_prime_locally(config_path : str, output_path : str, threads : str, progs : list, dry : bool):
    config_path = path.abspath(config_path)
    output_path = path.abspath(output_path)
    max_msg_size = get_max_msg_size(config_path)
    task_id = datetime.now().strftime("p_%d%m%Y-%H%M%S")

    cmd = ['mpirun', '-n', '1', prime_exe , config_path , output_path]
    for rank, prog in enumerate(progs, start=1):
        if prog[:7] == 'parsec.':
          cmd += [':',  '-n', '1', 'parsecmgmt', 
                  '-a', 'run', 
                  '-c', 'icc', 
                  '-i', 'simsmall', 
                  '-k', 
                  '-s', "%s -i %s -p %d -l %s " % (pinwrapper_exe, task_id, rank, max_msg_size), 
                  '-p', prog, 
                  '-n', threads]
        else:
          cmd += [':',  '-n', '1', pinwrapper_exe, 
                  '-i', task_id,
                  '-p', str(rank),
                  '-l', max_msg_size, 
                  prog]
    
    print('export OMP_NUM_THREADS=%s' % threads)
    for word in cmd:
      print(word, end=" "),
    print("")

    if not dry:
      os.environ['OMP_NUM_THREADS'] = threads
      os.execvp(cmd[0], cmd)


def main():
    parser = OptionParser(usage = "usage: run_prime [options] prog1 [prog2,prog3,...]")
    parser.add_option("-c", "--config_path",
                      dest="config_path", default=prime_path + "/xml/config.xml",
                      metavar="CONFIG_PATH", help="use CONFIG_PATH to configure the simulated system (default: xml/config.xml)")
    
    parser.add_option("-o", "--output_path",
                      dest="output_path", default=prime_path + "/output/config.out",
                      metavar="OUTPUT_PATH", help="write the report to OUTPUT_PATH (default: output/config.out)") 

    parser.add_option("-t", "--threads",
                       dest="threads", default='1', 
                       metavar="THREADS", help="number of threads per task")   

    parser.add_option("-d", "--dry",
                       dest="dry", default=False, action="store_true",
                       metavar="DRY", help="print execution command")   

    parser.add_option("-l", "--local",
                       dest="local", default=False, action="store_true",
                       metavar="LOCAL", help="execute on local machine")   

    parser.add_option("-p", "--params",
                       dest="params", default="",
                       metavar="PARAMS", help="params to pass to slurm")   

    parser.add_option("-b", "--background",
                       dest="background", default=False, action="store_true",
                       metavar="BACKGROUND", help="run task in background")   

    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.error("You need to specify at least one program to run")
    if not options.local:
      run_prime_slurm(options.config_path, options.output_path, options.threads, args, options.dry, options.background, options.params)
    else:
      run_prime_locally(options.config_path, options.output_path, options.threads, args, options.dry)



if __name__ == "__main__":
    main()
